<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#000000">
    <meta name="msapplication-navbutton-color" content="#000000">
    <title>Galerie - Anouche Lelong</title>
    <script src="visitor-tracker.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Flèches de navigation discrètes */
        .nav-arrows {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            pointer-events: none;
            z-index: 10;
        }
        
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            opacity: 0.3;
            transition: opacity 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
        }
        
        .nav-arrow:hover {
            opacity: 0.6;
        }
        
        .nav-arrow.left {
            left: 150px;
        }
        
        .nav-arrow.right {
            right: 150px;
        }
        
        .nav-arrow::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            border-top: 2px solid rgba(255, 255, 255, 0.8);
            border-left: 2px solid rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
        }
        
        .nav-arrow.left::before {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        
        .nav-arrow.right::before {
            transform: translate(-50%, -50%) rotate(135deg);
        }
        
        /* Barre de glissement de caméra */
        .camera-slider {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
        }
        
        .slider-track {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .slider-ball {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            cursor: grab;
            transition: transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .slider-ball:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* Bouton retour discret */
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            backdrop-filter: blur(10px);
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.05);
        }

        .back-button::before {
            content: '';
            width: 8px;
            height: 8px;
            border-left: 2px solid rgba(255, 255, 255, 0.8);
            border-bottom: 2px solid rgba(255, 255, 255, 0.8);
            transform: rotate(45deg) translateX(1px);
        }

        /* Responsive pour mobile */
        @media (max-width: 768px) {
            canvas {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
            }

            .nav-arrow {
                width: 50px;
                height: 50px;
                opacity: 0.6;
            }

            .nav-arrow.left {
                left: 20px;
            }

            .nav-arrow.right {
                right: 20px;
            }

            .nav-arrow::before {
                width: 15px;
                height: 15px;
                border-width: 3px;
            }

            .camera-slider {
                bottom: 20px;
                width: 150px;
                height: 10px;
                background: rgba(255, 255, 255, 0.3);
            }

            .slider-ball {
                width: 25px;
                height: 25px;
            }

            .back-button {
                width: 35px;
                height: 35px;
                top: 20px;
                left: 20px;
            }

            .back-button::before {
                width: 7px;
                height: 7px;
            }
        }

        @media (max-width: 480px) {
            .nav-arrow {
                width: 45px;
                height: 45px;
            }

            .nav-arrow.left {
                left: 15px;
            }

            .nav-arrow.right {
                right: 15px;
            }

            .nav-arrow::before {
                width: 12px;
                height: 12px;
                border-width: 2px;
            }

            .camera-slider {
                bottom: 15px;
                width: 120px;
                height: 8px;
            }

            .slider-ball {
                width: 20px;
                height: 20px;
            }

            .back-button {
                width: 30px;
                height: 30px;
                top: 15px;
                left: 15px;
            }

            .back-button::before {
                width: 6px;
                height: 6px;
            }
        }

        /* Support orientation paysage mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .back-button {
                top: 10px;
                left: 10px;
            }

            .nav-arrow.left {
                left: 15px;
            }

            .nav-arrow.right {
                right: 15px;
            }

            .camera-slider {
                bottom: 20px;
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <a href="landing.html?project=terminal" class="back-button"></a>
    
    <!-- Flèches de navigation discrètes -->
    <div class="nav-arrows">
        <div class="nav-arrow left" title="Tourner à gauche"></div>
        <div class="nav-arrow right" title="Tourner à droite"></div>
    </div>
    
    <!-- Barre de glissement de caméra -->
    <div class="camera-slider" id="cameraSlider" title="Faire glisser pour tourner la caméra">
        <div class="slider-track">
            <div class="slider-ball" id="sliderBall"></div>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
    <script>
        // ===== CONFIGURATION MODULAIRE =====
        // Modifiez ces valeurs pour personnaliser l'expérience
        
        const CONFIG = {
            // Taille des écrans
            screenSize: 5,
            screenDistance: 3,
            
            // Texte personnalisable
            text: {
                content: `Installation composée de deux passeports imprimés à grande échelle (2 m sur 3 m), l'un français, l'autre russe, exposés dans des espaces publics ou frontaliers. Ce projet interroge la manière dont des documents censés garantir l'identité deviennent des instruments de séparation. Il raconte une histoire d'amour traversée par des régimes de visas, des territoires, des délais et des justificatifs, révélant comment la liberté de circulation, loin d'être un droit universel, demeure un privilège accordé selon la géographie du pouvoir. L'amour ici n'est pas un prétexte : il est le point de départ, la voix qui insiste, qui attend, qui persiste malgré les mois d'incertitude et les preuves à fournir. En déplaçant ces objets administratifs hors de leur contexte, ce projet rend visible l'absurde et la violence des frontières invisibles, et montre que l'amour, lorsqu'il se heurte à la bureaucratie, devient un acte politique malgré lui.`,
                font: '300 36px "Helvetica Neue", Helvetica, Arial, sans-serif',
                color: '#ffffff',
                backgroundColor: '#000000',
                lineHeight: 52,
                startY: 650,
                // Marges pour le découpage du texte
                margins: {
                    desktop: 100,
                    mobile: 1  // Marges ultra réduites sur mobile pour texte très long
                }
            },
            
            // Vidéo Vimeo
            video: {
                url: 'https://player.vimeo.com/video/1100817715?h=your_hash_here&autoplay=1&title=0&byline=0&portrait=0&dnt=1&sidedock=0&pip=0&controls=1&loop=1&muted=0&transparent=0&autopause=0&showinfo=0&rel=0&color=ffffff&background=000000'
            },
            
            // Images
            images: {
                left: 'ftau.jpg',
                right: 'foto.jpg'
            }
        };

        // ===== INITIALISATION =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // ===== FONCTIONS MODULAIRES =====
        
        // Fonction pour créer le texte avec marges adaptatives
        function createTextCanvas() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            
            // Fond
            ctx.fillStyle = CONFIG.text.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Texte
            ctx.fillStyle = CONFIG.text.color;
            ctx.font = CONFIG.text.font;
            ctx.textAlign = 'center';
            
            // Découpage du texte en lignes
            const words = CONFIG.text.content.split(' ');
            const lines = [];
            let currentLine = words[0];
            
            // Marges adaptatives selon mobile/desktop
            const isMobile = window.innerWidth <= 768 || window.innerHeight <= 768;
            const textMargin = isMobile ? CONFIG.text.margins.mobile : CONFIG.text.margins.desktop;
            
            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + ' ' + word).width;
                if (width < canvas.width - textMargin) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            
            // Affichage du texte
            const centerX = canvas.width / 2;
            lines.forEach((line, index) => {
                ctx.fillText(line, centerX, CONFIG.text.startY + index * CONFIG.text.lineHeight);
            });
            
            return canvas;
        }

        // Fonction pour créer la vidéo
        function createVideo() {
            const videoContainer = document.createElement('div');
            videoContainer.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.8);
                width: 95vw;
                height: 53vw;
                max-width: 1600px;
                max-height: 900px;
                pointer-events: none;
                z-index: 10;
            `;
            
            const vimeoIframe = document.createElement('iframe');
            vimeoIframe.src = CONFIG.video.url;
            vimeoIframe.style.cssText = `
                width: 100%;
                height: 100%;
                border: none;
                pointer-events: auto;
            `;
            vimeoIframe.allow = 'autoplay; fullscreen; picture-in-picture';
            vimeoIframe.allowFullscreen = true;
            
            videoContainer.appendChild(vimeoIframe);
            document.body.appendChild(videoContainer);
            
            // Écran transparent dans Three.js
            const videoGeometry = new THREE.PlaneGeometry(CONFIG.screenSize, CONFIG.screenSize * 9/16);
            const videoMaterial = new THREE.MeshBasicMaterial({ 
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide 
            });
            const videoScreen = new THREE.Mesh(videoGeometry, videoMaterial);
            videoScreen.position.z = -CONFIG.screenDistance * 2;
            scene.add(videoScreen);
            
            return videoContainer;
        }

        // Fonction pour créer les images
        function createImages() {
            // Image gauche
            const leftImageTexture = new THREE.TextureLoader().load(CONFIG.images.left);
            const leftMaterial = new THREE.MeshBasicMaterial({
                map: leftImageTexture,
                side: THREE.DoubleSide
            });
            const leftScreen = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.screenSize * 2, CONFIG.screenSize * 2 * 9/16),
                leftMaterial
            );
            leftScreen.position.x = -CONFIG.screenDistance * 2.5;
            leftScreen.rotation.y = Math.PI/2;
            scene.add(leftScreen);

            // Image droite
            const rightImageTexture = new THREE.TextureLoader().load(CONFIG.images.right);
            const rightMaterial = new THREE.MeshBasicMaterial({
                map: rightImageTexture,
                side: THREE.DoubleSide
            });
            const rightScreen = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.screenSize * 2, CONFIG.screenSize * 2 * 9/16),
                rightMaterial
            );
            rightScreen.position.x = CONFIG.screenDistance * 2.5;
            rightScreen.rotation.y = -Math.PI/2;
            scene.add(rightScreen);
        }

        // Fonction pour créer le texte
        function createText() {
            const textCanvas = createTextCanvas();
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                side: THREE.DoubleSide
            });
            const textScreen = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.screenSize * 3, CONFIG.screenSize * 3),
                textMaterial
            );
            textScreen.position.z = CONFIG.screenDistance * 3;
            textScreen.rotation.y = Math.PI;
            scene.add(textScreen);
        }

        // ===== CRÉATION DE LA SCÈNE =====
        const videoContainer = createVideo();
        createImages();
        createText();

        // ===== GESTION DE LA VIDÉO =====
        function updateVideoPosition() {
            const cameraRotation = camera.rotation.y;
            if (Math.abs(cameraRotation) < 0.5) {
                videoContainer.style.display = 'block';
            } else {
                videoContainer.style.display = 'none';
            }
        }

        // ===== CONTRÔLES DE LA CAMÉRA =====
        let isDragging = false;
        let previousMousePosition = { x: 0 };
        const maxRotation = Math.PI;

        // Gestionnaires de clic pour recentrer la caméra
        let doubleClickTimeout;
        
        function handleDoubleClick(targetRotation) {
            camera.rotation.y = targetRotation;
        }
        
        function handleClick(targetRotation) {
            if (doubleClickTimeout) {
                clearTimeout(doubleClickTimeout);
                doubleClickTimeout = null;
                handleDoubleClick(targetRotation);
            } else {
                doubleClickTimeout = setTimeout(() => {
                    doubleClickTimeout = null;
                }, 300);
            }
        }

        // Contrôles souris
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX };
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaMove = { x: e.clientX - previousMousePosition.x };
            camera.rotation.y = Math.max(-maxRotation, Math.min(maxRotation, 
                camera.rotation.y - deltaMove.x * 0.005));
            previousMousePosition = { x: e.clientX };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Clics sur le canvas
        document.addEventListener('click', (e) => {
            if (e.target.id === 'canvas') {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const centerX = rect.width / 2;
                
                if (x < rect.width * 0.3) {
                    handleClick(Math.PI/2);
                } else if (x > rect.width * 0.7) {
                    handleClick(-Math.PI/2);
                } else {
                    if (Math.abs(camera.rotation.y) < 0.5) {
                        handleClick(0);
                    } else if (Math.abs(camera.rotation.y - Math.PI) < 0.5) {
                        handleClick(Math.PI);
                    }
                }
            }
        });

        // ===== FLÈCHES DE NAVIGATION =====
        const leftArrow = document.querySelector('.nav-arrow.left');
        const rightArrow = document.querySelector('.nav-arrow.right');
        
        const faces = [0, Math.PI/2, Math.PI, -Math.PI/2];
        let currentFaceIndex = 0;
        
        leftArrow.addEventListener('click', () => {
            currentFaceIndex = (currentFaceIndex + 1) % faces.length;
            camera.rotation.y = faces[currentFaceIndex];
        });
        
        rightArrow.addEventListener('click', () => {
            currentFaceIndex = (currentFaceIndex - 1 + faces.length) % faces.length;
            camera.rotation.y = faces[currentFaceIndex];
        });

        // ===== SLIDER DE CAMÉRA =====
        const cameraSlider = document.getElementById('cameraSlider');
        const sliderBall = document.getElementById('sliderBall');
        let isSliderDragging = false;
        let startX = 0;
        let startLeft = 0;
        let ballPosition = 50;

        function updateBallPosition() {
            sliderBall.style.left = ballPosition + '%';
        }

        function updateCameraRotation() {
            const rotation = (ballPosition - 50) / 50 * Math.PI;
            camera.rotation.y = rotation;
        }

        updateBallPosition();

        // Gestionnaires du slider
        sliderBall.addEventListener('mousedown', (e) => {
            isSliderDragging = true;
            startX = e.clientX;
            startLeft = ballPosition;
            sliderBall.style.cursor = 'grabbing';
        });

        sliderBall.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isSliderDragging = true;
            startX = e.touches[0].clientX;
            startLeft = ballPosition;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isSliderDragging) return;
            const deltaX = e.clientX - startX;
            const sliderWidth = cameraSlider.offsetWidth;
            const deltaPercent = (deltaX / sliderWidth) * 100;
            ballPosition = Math.max(0, Math.min(100, startLeft + deltaPercent));
            updateBallPosition();
            updateCameraRotation();
        });

        document.addEventListener('touchmove', (e) => {
            if (!isSliderDragging) return;
            e.preventDefault();
            const deltaX = e.touches[0].clientX - startX;
            const sliderWidth = cameraSlider.offsetWidth;
            const deltaPercent = (deltaX / sliderWidth) * 100;
            ballPosition = Math.max(0, Math.min(100, startLeft + deltaPercent));
            updateBallPosition();
            updateCameraRotation();
        });

        document.addEventListener('mouseup', () => {
            if (isSliderDragging) {
                isSliderDragging = false;
                sliderBall.style.cursor = 'grab';
            }
        });

        document.addEventListener('touchend', () => {
            if (isSliderDragging) {
                isSliderDragging = false;
            }
        });

        // ===== ANIMATION ET REDIMENSIONNEMENT =====
        function animate() {
            requestAnimationFrame(animate);
            updateVideoPosition();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Recréer le texte quand la taille change pour adapter les marges
            const newIsMobile = window.innerWidth <= 768 || window.innerHeight <= 768;
            const currentIsMobile = window.innerWidth <= 768 || window.innerHeight <= 768;
            
            if (newIsMobile !== currentIsMobile) {
                // Nettoyer l'ancien texte
                scene.children = scene.children.filter(child => child.geometry.type !== 'PlaneGeometry' || child.position.z !== CONFIG.screenDistance * 3);
                
                // Recréer le texte avec les bonnes marges
                createText();
            }
        });

        animate();
    </script>
</body>
</html> </html> 
